<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_1131046_aa_man_0.APIClass</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Provides methods to interact with Automation Anywhere</description>
        <name>APIClass</name>
        <script><![CDATA[var APIClass = Class.create();
APIClass.prototype = {
    initialize: function(defaultPass = "") {
        this.defaultPass = defaultPass;
    },
    type: 'APIClass',
    restSrc: 'x_1131046_aa_man_0.AA_API',
    log: "SI | APIClass | ",
    endpoint: "https://merck-dev.my.automationanywhere.digital/",
    environment: "DEV",
    licenseFname: {
        'Development': 'Bot creator',
        'Runtime': 'Unattended bot runner',
        'AttendedRuntime': 'Attended bot runner',
        'CitizenDeveloper': 'Citizen developer'
    },

    /**
     * Converts Javascript STRING object to JSON string
     * @param {json} obj - An object whose values needs to be transformed from Javascript STRING into JSON.STRING.
     * @return {json} result - result will contains values of datatype JSON.STRING
     */
    convertToJSONString: function(obj) {
        var newObj = {};
        for (const [key, value] of Object.entries(obj)) {
            newObj[key] = JSON.stringify(value);
        }
        return newObj;
    },

    /**
     * Checks if the object doesn't have empty values.
     * @param {json} rawInput - An object whose values are STRING type and need to be verified for NON-EMPTY.
     * @return {boolean} true/false - returns true if values are non-empty else returns false.
     */
    checkAllAreNonEmpty: function(rawInput) {
        for (const [key, value] of Object.entries(rawInput)) {
            if (rawInput[key].length <= 0) return false;
        }
        return true;
    },

    /**
     * @param {json} inputData - inputData json should contains keys i.e 
     *      firstName(string),
     *      lastName(string),
     *      mailID(string),
     *      username(string),
     *      roleIDs(string) - role IDs(NOT NAME) separated by ",". Ex: If only one: "334" or More than one: "334,335,336",
     *      licenses(string) - License names separated by "," as specified for the roles.
     * @return {json} result - result will have keys i.e. 
     *      isCreated[bool] - if the user is created, it will be true, else false
     *      id[number] - if isCreated is true, then it will contain id of the user and 
     *      msg(string) - if user creation failed[isCreated=false], then msg will holds the error message.
     */
    createUser: function(inputData) {
        var logName = this.log + "CreateUser >> ";
        var endpoint = this.endpoint + "v2/usermanagement/users";
        var result = {};
        result.isCreated = false;

        gs.info(logName + "Received a request to Create a New user with details: " + JSON.stringify(inputData));

        try {
            let tempData = {
                ...inputData
            };
            delete tempData.licenses;

            if (this.checkAllAreNonEmpty(tempData)) {
                tempData = {
                    ...inputData
                };
                tempData.endpoint = endpoint;
                tempData.roleIDs = inputData.roleIDs.length > 0 ? inputData.roleIDs.split(",") : [];
                tempData.licenses = inputData.licenses.length > 0 ? inputData.licenses.split(",") : [];
                // tmpRoles.forEach((id) => roles.push({"id": id}));
                // var roles = [],
                //     licenses = [];

                //tmpRoles = tmpRoles.map(Number);
                // tmpLicenses.forEach((name) => licenses.push(name));

                // tmpRoles = JSON.stringify(tmpRoles);
                // tmpLicenses = JSON.stringify(tmpLicenses);

                let newData = this.convertToJSONString(tempData);

                //Initialize the required REST Message
                var req = this.makeReq('CreateUser');
                req.setStringParameterNoEscape("endpoint", newData.endpoint);
                req.setStringParameterNoEscape("token", this.getToken());
                req.setStringParameterNoEscape('username', newData.username);
                req.setStringParameterNoEscape('firstName', newData.firstName);
                req.setStringParameterNoEscape('lastName', newData.lastName);
                req.setStringParameterNoEscape('mailID', newData.mailID);
                //req.setStringParameterNoEscape('pass', this.defaultPass);
                req.setStringParameterNoEscape('enableAutoLogin', true);
                req.setStringParameterNoEscape('roles', newData.roleIDs);
                req.setStringParameterNoEscape('licenses', newData.licenses);

                var response = req.execute();
                var responseBody = response.getBody();
                var httpStatus = response.getStatusCode();
                gs.info(logName + "Result - HTTP status Code: " + httpStatus);

                var parsed = JSON.parse(responseBody);
                if (httpStatus == 201) {
                    // User Created Successfully
                    result.isCreated = true;
                    gs.info(logName + "SUCCESS | New ID is " + parsed.id);
                    result.id = parsed.id;
                } else {
                    //Failed to create user through api
                    result.msg = parsed.message;
                    gs.error(logName + "FAILED | Reason is " + parsed.message);
                }
            } else {
                let msg = "One of the required field for user creation is EMPTY.";
                gs.error(logName + msg);
                result.msg = msg;
            }

        } catch (e) {
            gs.error(logName + "Exception: " + e);
            result.msg = "An error occurred while creating the user.";
        }
        return result;
    },

    /**
     * @param {string} uID - x_m_uid of the user to check whether it matches with existing uID of user who possessing "id". In order to avoid deletion of other users.
     * @param {string} userID - id of the user which was received after user has been created.
     * @return {json} result - result will have keys i.e. isCreated[bool] - if the user is created, it will be true and msg(string) - if user creation failed, then msg will holds the error message.
     */
    deleteUsr: function(uID, userID) {
        var logName = this.log + "DeleteUsr >> ";
        var endpoint = this.endpoint + "v2/usermanagement/users/";

        if (userID) {
            gs.info(logName + "Checking if user with id " + userID + " exists in AA...");
            var exists = this.getUserByID(userID);
            if (!exists) {
                gs.error(logName + "User doesn't exists in Automation Anywhere.");
                return 1;
            } else {
                if (exists.username.toLowerCase() == uID.toLowerCase()) {
                    gs.error(logName + "Username matched with uID...");
                    endpoint = endpoint + userID;

                    var req = this.makeReq('RemoveUser');
                    req.setStringParameterNoEscape("endpoint", endpoint);
                    req.setStringParameterNoEscape("token", this.getToken());
                    var response = req.execute();
                    var responseBody = response.getBody();
                    var httpStatus = response.getStatusCode();
                    gs.info(logName + "SUCCESS | Response Status: " + httpStatus);
                    if (httpStatus == 204)
                        return 0;
                    else {
                        gs.error(logName + "FAILED | Reason is " + responseBody);
                    }
                } else {
                    gs.error(logName + "You are trying to delete user having UID: " + uID + ". But, Username recorded with above ID in AA is " + exists.username);
                    return 1;
                }
            }
        }
    },

    getToken: function() {
        // API call made to AA to get the TOKEN

        var endpoint = this.endpoint + "v2/authentication";
        var req = this.makeReq('Authentication');
        req.setStringParameterNoEscape("endpoint", endpoint);
        req.setStringParameterNoEscape('api_key', 'HVGFzzmqauks}rqP=y7y?~XomYrBUJW6_dX|@Zf;');
        req.setStringParameterNoEscape('username', 'X253816');
        var response = req.execute();
        var responseBody = response.getBody();
        var httpStatus = response.getStatusCode();
        if (httpStatus == 200) {
            // Get the Access Token
            return JSON.parse(responseBody).token;
        }
    },

    /**
     * @param {string} id - id of the user which was received after user has been created.
     * @return {json} result - result will contain all the keys that user has configured or assigned after user has been created.
     */
    GetUserDetailsByID: function(userID) {
        var logName = this.log + "GetUserDetailsByID >> ";

        // API Call made to AA to get User info by User ID
        if (userID) {
            gs.info(logName + "Checking info for Id: " + userID);
            var endpoint = this.endpoint + "v2/usermanagement/users/" + userID;

            var req = this.makeReq('GetUserDetailsByID');
            req.setStringParameterNoEscape("endpoint", endpoint);
            req.setStringParameterNoEscape("token", this.getToken());
            req.setStringParameterNoEscape('id', userID);

            var response = req.execute();
            var responseBody = response.getBody();
            var httpStatus = response.getStatusCode();

            gs.info(logName + "Response Status: " + httpStatus);
            if (httpStatus == 404)
                return;
            if (httpStatus == 401)
                return this.GetUserDetailsByID(userID);
            if (httpStatus == 200)
                return JSON.parse(responseBody);
        }
    },

    getLicenseFrontName: function(name) {
        var result = this.licenseFname[name];
        if (result)
            return result;
        return "";
    },

    insertLicenses: function() {
        // Insert roles into table named "aa_roles". So, to keep updated whenever a new role is created in AA.
        // This method is called for every 6 hours from Scheduled Jobs and add the roles, if the "id" doesn't exists.
        var logName = this.log + "insertLicenses >> ";
        var endpoint = this.endpoint + "v2/license/product/list";

        var req = this.makeReq('GetLicenseList');
        req.setStringParameterNoEscape("endpoint", endpoint);
        req.setStringParameterNoEscape("token", this.getToken());

        var response = req.execute();
        var responseBody = response.getBody();
        var httpStatus = response.getStatusCode();
        gs.info(logName + "Response Status: " + httpStatus);

        if (httpStatus == 200) {
            var licenseList = JSON.parse(responseBody).list;
            licenseList.forEach((license) => {
                if ('feature' in license) {
                    var parent = license.name;
                    var feature = license.feature;
                    var gr = new GlideRecord("x_1131046_aa_man_0_licenses");
                    gr.addQuery('id', feature.id);
                    gr.query();
                    if (!gr.hasNext()) {
                        gs.info(logName + "License doesn't exists. Adding it." + license.id);
                        gr.initialize();
                        gr.setValue('id', feature.id);
                        gr.setValue('name', feature.name);
                        gr.setValue('parent', parent);
                        gr.setValue('available_count', feature.availableCount);
                        gr.setValue('purchased_count', feature.purchasedCount);
                        gr.setValue('used_in_this_control_room', feature.usedCountByThisCr);
                        gr.setValue('used_in_all_control_room', feature.usedCountByAllCr);
                        gr.setValue('front_name', this.getLicenseFrontName(feature.name));
                        gr.insert();
                    }
                }
            });
        } else {
            gs.error(logName + "Error Occurred. " + responseBody);
        }
    },

    insertRoles: function() {
        // Insert roles into table named "aa_roles". So, to keep updated whenever a new role is created in AA.
        // This method is called for every 6 hours from Scheduled Jobs and add the roles, if the "id" doesn't exists.
        var logName = this.log + "insertRoles >> ";
        var endpoint = this.endpoint + "v2/usermanagement/roles/list";

        var req = this.makeReq('FetchRoles'); // Create REST Request
        req.setStringParameterNoEscape("endpoint", endpoint);
        req.setStringParameterNoEscape("token", this.getToken()); // Set the Variable value
        var response = req.execute(); // Execute the REST request
        var responseBody = response.getBody(); // Read the RESPONSE
        var httpStatus = response.getStatusCode(); // Read the RESPONSE status Code
        gs.info(logName + "Response Status: " + httpStatus);
        if (httpStatus == 200) {
            var rolesList = JSON.parse(responseBody).list;
            rolesList.forEach((role) => {
                var gr = new GlideRecord("x_1131046_aa_man_0_roles");
                gr.addQuery('id', role.id);
                gr.query();
                if (!gr.hasNext()) {
                    gs.info(logName + "Role doesn't exists. Adding it." + role.id);
                    gr.initialize();
                    gr.setValue("id", role.id);
                    gr.setValue("name", role.name);
                    gr.setValue("description", role.description);
                    gr.insert();
                }
            });
        } else {
            gs.error(logName + "Error Occurred. " + responseBody);
        }
    },

    insertUsers: function() {
        var logName = this.log + "insertUsers >> ";
        var endpoint = this.endpoint + "v2/usermanagement/users/list";
        gs.info(logName + "Endpoint: " + endpoint);

        var req = this.makeReq('FetchUsers'); // Create REST Request
        req.setStringParameterNoEscape("endpoint", endpoint);
        req.setStringParameterNoEscape("token", this.getToken());

        var response = req.execute(); // Execute the REST request
        var responseBody = response.getBody(); // Read the RESPONSE
        var httpStatus = response.getStatusCode(); // Read the RESPONSE status Code
        gs.info(logName + "Response Status: " + httpStatus);

        if (httpStatus == 200) {
            var userList = JSON.parse(responseBody).list;
            userList.forEach((user) => {
                var gr = new GlideRecord("x_1131046_aa_man_0_users");
                gr.addQuery('user_id', user.id);
                gr.query();
                if (!gr.hasNext()) {
                    gs.info(logName + "User doesn't exists. Adding it." + user.id);
                    gr.initialize();
                    gr.setValue("user_id", user.id);
                    gr.setValue("username", user.username);
                    gr.setValue("first_name", user.firstName);
                    gr.setValue("last_name", user.lastName);
                    gr.setValue("mail_id", user.email);
                    gr.setValue("environment", this.environment);
                    gr.setValue("enable_auto_login", user.enableAutoLogin);

                    if (user.roles.length > 0) {
                        var tmpRoles = [];
                        user.roles.forEach((role) => {
                            tmpRoles.push(role.id);
                        });
                        var roles = this.RecordClass().fetchGivenField('x_1131046_aa_man_0_roles', 'sys_id', 'id', tmpRoles);
                        gr.setValue("roles", roles);
                    }

                    if (user.licenseFeatures.length > 0) {
                        var tmpLicenses = [];
                        user.licenseFeatures.forEach((license) => {
                            tmpLicenses.push(license);
                        });
                        var licenses = this.RecordClass().fetchGivenField('x_1131046_aa_man_0_licenses', 'id', 'name', tmpLicenses);
                        gs.info("License for the user: " + user.id + " is: " + licenses);
                        gr.setValue("licenses", licenses);
                    }
                    gr.insert();
                }
            });
        } else {
            gs.error(logName + "Error Occurred. " + responseBody);
        }
    },

    makeReq: function(method) {
        return new sn_ws.RESTMessageV2(this.restSrc, method);
    },

    /**
     * @param {json} inputData - inputData json should contains keys i.e 
     *      userID(string),
     *      username(string),
     *      firstName(string),
     *      lastName(string),
     *      mailID(string),
     *      roleIDs(string) - role IDs(NOT NAME) separated by ",". Ex: If only one: "334" or More than one: "334,335,336",
     *      licenses(string) - License names separated by "," as specified for the roles.
     * @return {json} result - result will have keys i.e. 
     *          isUpdated[bool] - if the roles are updated to AA, it will be true, else false and 
     *          msg(string) - if unable to update result[isUpdated=false, msg], then msg will holds the error message
     */
    updateUser: function(inputData) {
        var logName = this.log + "updateUser >> ";
        var endpoint = this.endpoint + "v2/usermanagement/users/" + inputData.userID;
        var result = {};

        try {
            let tempData = {
                ...inputData
            };
            delete tempData.licenses;

            if (this.checkAllAreNonEmpty(tempData)) {
                tempData = {
                    ...inputData
                };
                tempData.endpoint = endpoint;
                tempData.roleIDs = inputData.roleIDs.length > 0 ? inputData.roleIDs.split(",") : [];
                tempData.licenses = inputData.licenses.length > 0 ? inputData.licenses.split(",") : [];

                // var tmpRoles = inputData.roleIDs.split(",");
                // var roles = [];
                // tmpRoles.forEach((id) => {
                //     roles.push(Number(id));
                // });

                let newData = this.convertToJSONString(tempData);

                //Initialize the required REST Message
                var req = this.makeReq('UpdateUser');
                req.setStringParameterNoEscape("endpoint", newData.endpoint);
                req.setStringParameterNoEscape("token", this.getToken());
                req.setStringParameterNoEscape('username', newData.username);
                req.setStringParameterNoEscape('firstName', newData.firstName);
                req.setStringParameterNoEscape('lastName', newData.lastName);
                req.setStringParameterNoEscape('mailID', newData.mailID);
                req.setStringParameterNoEscape('enableAutoLogin', true);
                req.setStringParameterNoEscape('roles', newData.roleIDs);
                req.setStringParameterNoEscape('licenses', newData.licenses);

                var response = req.execute();
                var responseBody = response.getBody();
                var httpStatus = response.getStatusCode();
                gs.info(logName + "Result - HTTP status Code: " + httpStatus);
                var parsed = JSON.parse(responseBody);
                if (httpStatus == 200) {
                    // roles updated successfully
                    result.isUpdated = true;
                } else {
                    //Failed to update
                    result.isUpdated = false;
                    result.msg = parsed.message;
                    gs.error(logName + "FAILED | Reason is " + parsed.message);
                }
            } else {
                let msg = "One of the required field for user update is EMPTY.";
                gs.error(logName + msg);
                result.msg = msg;
            }
        } catch (e) {
            gs.error(logName + "Exception: " + e);
            result.isUpdated = false;
            result.msg = "An error occurred while updating the user.";
        }
        return result;
    }
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-02-14 13:48:14</sys_created_on>
        <sys_id>127a306e075482101808fe4f7c1ed0dd</sys_id>
        <sys_mod_count>68</sys_mod_count>
        <sys_name>APIClass</sys_name>
        <sys_package display_value="AA Management" source="x_1131046_aa_man_0">7630a7f79340021030ae7c5efaba105f</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="AA Management">7630a7f79340021030ae7c5efaba105f</sys_scope>
        <sys_update_name>sys_script_include_127a306e075482101808fe4f7c1ed0dd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-03-27 12:10:30</sys_updated_on>
    </sys_script_include>
</record_update>
